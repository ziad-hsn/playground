package main

import (
	"bufio"
	"fmt"
	"regexp"
	"strings"
)

// All code here is generated by Gemini AND/OR ChatGPT

const (
	ColorReset = "\033[0m"
	ColorRed   = "\033[31m"
	ColorBold  = "\033[1m"
)

func PrintWikiSummaries(pipeline <-chan WikiSummaryResponse) {
	fmt.Println("\n=== Wikipedia Article Summaries ===")

	for chunkSummary := range pipeline {
		if chunkSummary.Err != nil {
			fmt.Printf("  Error: failed to get a chunk of summaries: %v\n", chunkSummary.Err)
			fmt.Println("----------------------------------------------------")
			continue
		}

		for _, summary := range chunkSummary.Summary {
			// Header line: Title (Url) or fallback
			pageHeaderText := ""
			if summary.Title != "" {
				pageHeaderText = summary.Title
				if summary.Url != "" {
					pageHeaderText += fmt.Sprintf(" (%s)", summary.Url)
				}
			} else if summary.Url != "" {
				pageHeaderText = fmt.Sprintf("(Untitled Page) (%s)", summary.Url)
			} else {
				pageHeaderText = "(Page Title and URL not available)"
			}
			fmt.Printf("\n%s\n", pageHeaderText)

			// PageID if present
			if summary.PageID != 0 {
				fmt.Printf("  PageID: %d\n", summary.PageID)
			}

			// Error reporting
			if summary.Err != nil {
				fmt.Printf("  Error: %v\n", summary.Err)
			}

			// Summary text block
			if summary.Summary != "" {
				fmt.Println("  Summary:")
				scanner := bufio.NewScanner(strings.NewReader(summary.Summary))
				for scanner.Scan() {
					fmt.Printf("    %s\n", scanner.Text())
				}
				if err := scanner.Err(); err != nil {
					fmt.Printf("    (Error reading summary for printing: %v)\n", err)
				}
			} else {
				fmt.Println("  Summary: (Not available)")
			}

			fmt.Println("----------------------------------------------------")
		}
	}
	fmt.Println("End of summaries.")
}

// highlightText wraps each case-insensitive occurrence of term in line
// with ANSI codes so it shows up in e.g. red and bold.
func highlightText(line, term string) string {
	if term == "" {
		return line
	}
	// escape term so meta-chars donâ€™t break the regex
	re := regexp.MustCompile("(?i)" + regexp.QuoteMeta(term))

	return re.ReplaceAllStringFunc(line, func(m string) string {
		// you can drop ColorBold if you only want color
		return ColorBold + ColorRed + m + ColorReset
	})
}

// printPageInfo is a helper function to print information for a single page.
// It adapts the display based on whether local grep matches were found.
func printPageInfo(grepResult WikiGrepOutput, searchedWord string, hasLocalMatches bool) {

	//stripMarkers := func(s string) string {
	//	return strings.ReplaceAll(s, "::", "")
	//}
	// Construct page header with Title and URL
	pageHeaderText := ""
	if grepResult.Title != "" {
		pageHeaderText = grepResult.Title
		if grepResult.Url != "" {
			pageHeaderText += fmt.Sprintf(" (%s)", grepResult.Url)
		}
	} else if grepResult.Url != "" {
		pageHeaderText = fmt.Sprintf("(Untitled Page) (%s)", grepResult.Url)
	} else {
		pageHeaderText = "(Page Title and URL not available)"
	}
	fmt.Printf("\n%s\n", pageHeaderText) // Page header

	// Print PageID (indented)
	if grepResult.PageID != 0 {
		fmt.Printf("  PageID: %d\n", grepResult.PageID)
	}

	// Report an error if one occurred
	if grepResult.Err != nil {
		if hasLocalMatches {
			// This style was in the user's provided code for pages with matches + error
			fmt.Printf("  Error (note: matches were still found for this page): %v\n", grepResult.Err)
		} else {
			// For pages without local matches, a standard error message
			fmt.Printf("  Error: %v\n", grepResult.Err)
		}
	}

	if hasLocalMatches {
		// This section matches the style in the user's provided code for printing matches
		fmt.Println("  Matches found:")
		for _, matchSnippet := range grepResult.Matches { // Iterating without index for numbering
			scanner := bufio.NewScanner(strings.NewReader(matchSnippet))
			isFirstLineOfSnippet := true
			firstLinePrefix := "    - " // Style from user's code: dash prefix, no match number
			subsequentLineIndentation := strings.Repeat(" ", len(firstLinePrefix))

			for scanner.Scan() {
				line := scanner.Text()
				highlightedLine := highlightText(line, searchedWord)

				if isFirstLineOfSnippet {
					fmt.Printf("%s%s\n", firstLinePrefix, highlightedLine)
					isFirstLineOfSnippet = false
				} else {
					fmt.Printf("%s%s\n", subsequentLineIndentation, highlightedLine)
				}
			}
			if err := scanner.Err(); err != nil {
				// Indent scanner error consistent with snippet lines
				fmt.Printf("%s(Error reading snippet: %v)\n", subsequentLineIndentation, err)
			}
		}
	} else {
		// Message for pages without local grep matches
		fmt.Printf("  Matches: (No literal grep matches for \"%s\")\n", searchedWord)
	}
	fmt.Println("----------------------------------------------------") // Page separator
}

// PrintWikiGrepResults processes and prints Wikipedia grep results.
// Pages with local matches are printed first, followed by pages suggested by the API
// but having no local literal matches.
func PrintWikiGrepResults(pipeline <-chan WikiGrepOutput, searchedWord string) {
	// General title, as all suggested pages are now handled
	fmt.Printf("\n=== Wikipedia Grep Results for: \"%s\" ===\n", searchedWord)

	pagesWithMatchesPrintedCount := 0
	var pagesWithoutMatches []WikiGrepOutput

	// First pass: Print pages with local matches immediately, store others.
	for grepResult := range pipeline {
		if len(grepResult.Matches) > 0 {
			// Optional: If you wanted a specific sub-header for this section, it could go here,
			// guarded by `if pagesWithMatchesPrintedCount == 0`.
			// For now, printing directly under the main header as per original flow.
			printPageInfo(grepResult, searchedWord, true)
			pagesWithMatchesPrintedCount++
		} else {
			pagesWithoutMatches = append(pagesWithoutMatches, grepResult)
		}
	}

	// Second pass: Print stored pages that had no local matches.
	if len(pagesWithoutMatches) > 0 {
		fmt.Println("\n--- Pages suggested by API but with no literal local grep matches ---")
		for _, grepResult := range pagesWithoutMatches {
			printPageInfo(grepResult, searchedWord, false)
		}
	}

	// Final summary message
	totalProcessedPages := pagesWithMatchesPrintedCount + len(pagesWithoutMatches)
	if totalProcessedPages > 0 {
		fmt.Println("\n================================================")
		fmt.Println("End of grep result processing.")
	} else {
		// This implies the input pipeline was empty or yielded no results at all.
		fmt.Printf("\nNo pages were found or suggested by the API for \"%s\".\n", searchedWord)
	}
}

// generated by gemini
func extractContextByWords(body string, match [2]int, beforeWords, afterWords int) string {
	// 1. Find all non-space runs and record their offsets.
	reWords := regexp.MustCompile(`\S+`)
	locs := reWords.FindAllStringIndex(body, -1)

	type token struct {
		text       string
		start, end int
	}
	tokens := make([]token, len(locs))
	for i, loc := range locs {
		tokens[i] = token{
			text:  body[loc[0]:loc[1]],
			start: loc[0],
			end:   loc[1],
		}
	}

	// 2. Locate which tokens cover the match span.
	matchStart, matchEnd := match[0], match[1]
	var startTok, endTok int
	for i, tok := range tokens {
		if tok.start <= matchStart && matchStart < tok.end {
			startTok = i
		}
		if tok.start < matchEnd && matchEnd <= tok.end {
			endTok = i
			break
		}
	}

	// 3. Compute word-window bounds.
	s := startTok - beforeWords
	if s < 0 {
		s = 0
	}
	e := endTok + afterWords
	if e >= len(tokens) {
		e = len(tokens) - 1
	}

	// 4. Join the slice of tokens into one snippet.
	out := make([]string, e-s+1)
	for i := s; i <= e; i++ {
		out[i-s] = tokens[i].text
	}
	return strings.Join(out, " ")
}
